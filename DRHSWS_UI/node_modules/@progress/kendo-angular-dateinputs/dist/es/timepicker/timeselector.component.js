import { Component, ChangeDetectorRef, ChangeDetectionStrategy, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, NgZone, ViewChild, ViewChildren } from '@angular/core';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { IntlService } from '@progress/kendo-angular-intl';
import { cloneDate, getDate } from '@progress/kendo-date-math';
import { MIDNIGHT_DATE, MIN_TIME, MAX_TIME } from '../defaults';
import { TimeListComponent } from './timelist.component';
import { DOMService } from './services/dom.service';
import { TIME_PART } from './models/time-part.default';
import { getNow, hasChange, isInTimeRange, timeInRange } from '../util';
import { generateGetters, generateSnappers, snapTime, valueMerger } from './util';
var INTL_DATE_FORMAT = 'https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md';
var formatRegExp = new RegExp(TIME_PART.hour + "|" + TIME_PART.minute + "|" + TIME_PART.second + "|" + TIME_PART.dayperiod + "|literal");
var listReducer = function (state, list, idx, all) {
    if (state.length || !list.isActive) {
        return state;
    }
    return [{
            next: all[idx + 1] || list,
            prev: all[idx - 1] || list
        }];
};
var Direction;
(function (Direction) {
    Direction[Direction["Left"] = 0] = "Left";
    Direction[Direction["Right"] = 1] = "Right";
})(Direction || (Direction = {}));
/**
 * @hidden
 *
 * Represents the Kendo UI TimeSelector component for Angular.
 */
var TimeSelectorComponent = /** @class */ (function () {
    function TimeSelectorComponent(localization, cdr, element, intl, dom, zone) {
        this.localization = localization;
        this.cdr = cdr;
        this.element = element;
        this.intl = intl;
        this.dom = dom;
        this.zone = zone;
        /**
         * Specifies the time format used to display the time list columns.
         */
        this.format = 't';
        /**
         * Specifies the smallest valid time value.
         */
        this.min = cloneDate(MIN_TIME);
        /**
         * Specifies the biggest valid time value.
         */
        this.max = cloneDate(MAX_TIME);
        /**
         * Determines whether to display the **Cancel** button in the popup.
         */
        this.cancelButton = true;
        /**
         * Determines whether to display the **Now** button in the popup.
         *
         * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
         */
        this.nowButton = true;
        /**
         * Specifies the value of the TimeSelector component.
         */
        this.value = null;
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user cancels the selected value.
         */
        this.valueReject = new EventEmitter();
        /**
         * Fires each time the user focuses the input element.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-timeselector (focus)="handleFocus()"></kendo-timeselector>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         *
         * > To wire the event programmatically, use the `onFocus` property.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the input element gets blurred.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-timeselector (blur)="handleBlur()"></kendo-timeselector>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         *
         * > To wire the event programmatically, use the `onBlur` property.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        this.activeListIndex = -1;
        this.isActive = false;
        this.showNowButton = true;
        this.resolvedPromise = Promise.resolve(null);
        this._steps = {};
    }
    Object.defineProperty(TimeSelectorComponent.prototype, "steps", {
        get: function () {
            return this._steps;
        },
        /**
         * Configures the incremental steps of the TimeSelector.
         *
         * The available options are:
         * - `hour: Number`&mdash;Controls the incremental step of the hour value.
         * - `minute: Number`&mdash;Controls the incremental step of the minute value.
         * - `second: Number`&mdash;Controls the incremental step of the second value.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-timeselector format="HH:mm:ss" [steps]="steps"></kendo-timeselector>
         * `
         * })
         * class AppComponent {
         *   public steps = { hour: 2, minute: 15, second: 15 };
         * }
         * ```
         *
         * > If the incremental step is greater than `1`, the **Now** button will be hidden.
         */
        set: function (steps) {
            this._steps = steps || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelectorComponent.prototype, "current", {
        get: function () {
            return this._current;
        },
        set: function (value) {
            this._current = timeInRange(this.snapTime(cloneDate(value || MIDNIGHT_DATE), this.min), this.min, this.max);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelectorComponent.prototype, "componentClass", {
        /**
         * @hidden
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleKeydown = function (event) {
        var keyCode = event.keyCode;
        if (keyCode === 13 && !this.hasActiveButton()) {
            this.handleAccept();
        }
        else if (keyCode === 37 || keyCode === 39) {
            this.focusList(keyCode === 37 ? Direction.Left : Direction.Right);
        }
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
        if (this.localization) {
            this.subscriptions.add(this.localization
                .changes
                .subscribe(function () { return _this.cdr.markForCheck(); }));
        }
        this.dom.calculateHeights(this.element.nativeElement);
        this.init();
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.ngOnChanges = function (_) {
        this.init();
        this.verifyFormat();
    };
    TimeSelectorComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    /**
     * Focuses the TimeSelector component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="timeselector.focus()">Focus time picker</button>
     *  <kendo-timeselector #timeselector></kendo-timeselector>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    TimeSelectorComponent.prototype.focus = function () {
        var list = this.timeLists.first;
        if (!list) {
            return;
        }
        list.focus();
    };
    /**
     * Blurs the TimeSelector component.
     */
    TimeSelectorComponent.prototype.blur = function () {
        var list = this.timeLists.first;
        if (!list) {
            return;
        }
        list.blur();
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleAccept = function () {
        this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleNow = function () {
        this.current = getNow();
        this.handleChange(this.current);
        this.cdr.markForCheck();
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleReject = function () {
        this.current = this.value;
        this.valueReject.emit();
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleFocus = function () {
        var _this = this;
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        this.nextTick(function () {
            if (!_this.hasActiveComponent()) {
                return;
            }
            _this.onFocus.emit();
        });
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleListFocus = function (index) {
        this.activeListIndex = index;
        this.handleFocus();
    };
    /**
     * @hidden
     */
    TimeSelectorComponent.prototype.handleBlur = function () {
        var _this = this;
        this.activeListIndex = -1;
        this.nextTick(function () {
            if (_this.hasActiveComponent()) {
                return;
            }
            _this.isActive = false;
            _this.cdr.markForCheck();
            _this.onBlur.emit();
        });
    };
    TimeSelectorComponent.prototype.partStep = function (part) {
        return this.steps[part.type] || 1;
    };
    TimeSelectorComponent.prototype.init = function (changes) {
        if (!changes || hasChange(changes, 'format')) {
            this.dateFormatParts = this.intl.splitDateFormat(this.format);
            this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
        }
        if (!changes || hasChange(changes, 'steps')) {
            this.snapTime = snapTime(generateSnappers(this.steps));
        }
        if (!changes || hasChange(changes, 'value')) {
            this.current = this.value;
        }
        this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);
    };
    TimeSelectorComponent.prototype.focusList = function (dir) {
        if (!this.timeLists.length) {
            return;
        }
        this.timeLists.reduce(listReducer, [])
            .map(function (state) { return dir === Direction.Right ? state.next : state.prev; })
            .map(function (list) { return list && list.focus(); });
    };
    TimeSelectorComponent.prototype.handleChange = function (value) {
        this.value = value;
        this.valueChange.emit(cloneDate(value));
    };
    TimeSelectorComponent.prototype.hasActiveComponent = function () {
        return this.hasActiveTimeList() || this.hasActiveButton();
    };
    TimeSelectorComponent.prototype.hasActiveTimeList = function () {
        return this.timeLists.length && this.timeLists.reduce(function (isActive, list) { return isActive || list.isActive; }, false);
    };
    TimeSelectorComponent.prototype.hasActiveButton = function () {
        var _this = this;
        if (!this.accept) {
            return false;
        }
        return [this.accept, this.cancel, this.now].reduce(function (isActive, el) { return isActive || _this.dom.isActive(el); }, false);
    };
    TimeSelectorComponent.prototype.hasSteps = function () {
        var _this = this;
        var keys = Object.keys(this.steps);
        return keys.length !== keys.reduce(function (acc, k) { return acc + _this.steps[k]; }, 0);
    };
    TimeSelectorComponent.prototype.nextTick = function (f) {
        var _this = this;
        this.zone.runOutsideAngular(function () { return _this.resolvedPromise.then(function () { return f(); }); });
    };
    TimeSelectorComponent.prototype.verifyFormat = function () {
        this.dateFormatParts.forEach(function (part) {
            if (!formatRegExp.test(part.type)) {
                throw new Error("\n                    Provided format is not supported. Supported specifiers are T|t|H|h|m|s|a. See " + INTL_DATE_FORMAT + "\n                ");
            }
        });
    };
    TimeSelectorComponent.prototype.intlChange = function () {
        this.dateFormatParts = this.intl.splitDateFormat(this.format);
        this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
        this.cdr.markForCheck();
    };
    TimeSelectorComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'kendo-timeselector',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.timeselector'
                        }
                    ],
                    selector: 'kendo-timeselector',
                    template: "\n        <ng-container kendoTimeSelectorLocalizedMessages\n            i18n-accept=\"kendo.timeselector.accept|The Accept button text in the timeselector component\"\n            accept=\"Set\"\n\n            i18n-acceptLabel=\"kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component\"\n            acceptLabel=\"Set time\"\n\n            i18n-cancel=\"kendo.timeselector.cancel|The Cancel button text in the timeselector component\"\n            cancel=\"Cancel\"\n\n            i18n-cancelLabel=\"kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component\"\n            cancelLabel=\"Cancel changes\"\n\n            i18n-now=\"kendo.timeselector.now|The Now button text in the timeselector component\"\n            now=\"Now\"\n\n            i18n-nowLabel=\"kendo.timeselector.nowLabel|The label for the Now button in the timeselector component\"\n            nowLabel=\"Select now\"\n        >\n        </ng-container>\n        <div class=\"k-time-header\">\n            <span class=\"k-title\">\n                {{ intl.formatDate(current, format) }}\n            </span>\n            <button\n                #now\n                *ngIf=\"showNowButton\"\n                class=\"k-button k-bare k-time-now\"\n                [attr.title]=\"localization.get('nowLabel')\"\n                [attr.aria-label]=\"localization.get('nowLabel')\"\n                (click)=\"handleNow()\"\n                (focus)=\"handleFocus()\"\n                (blur)=\"handleBlur()\"\n            >{{localization.get('now')}}</button>\n        </div>\n        <div class=\"k-time-list-container\">\n            <span class=\"k-time-highlight\"></span>\n            <ng-template ngFor [ngForOf]=\"dateFormatParts\" let-part let-idx=\"index\">\n                <div\n                    class=\"k-time-list-wrapper\"\n                    role=\"presentation\" tabindex=\"-1\"\n                    [class.k-state-focused]=\"idx === activeListIndex\"\n                    *ngIf=\"part.type !== 'literal'\"\n                >\n                    <span class=\"k-title\">{{intl.dateFieldName(part)}}</span>\n                    <kendo-timelist\n                        [min]=\"min\"\n                        [max]=\"max\"\n                        [part]=\"part\"\n                        [step]=\"partStep(part)\"\n                        [(value)]=\"current\"\n                        (focus)=\"handleListFocus(idx)\"\n                        (blur)=\"handleBlur()\"\n                    ></kendo-timelist>\n                </div>\n                <div class=\"k-time-separator\" *ngIf=\"part.type === 'literal'\">\n                    {{part.pattern}}\n                </div>\n            </ng-template>\n        </div>\n        <div class=\"k-time-footer k-action-buttons\">\n            <button\n                #cancel\n                *ngIf=\"cancelButton\"\n                class=\"k-button k-time-cancel\"\n                [attr.title]=\"localization.get('cancelLabel')\"\n                [attr.aria-label]=\"localization.get('cancelLabel')\"\n                (click)=\"handleReject()\"\n                (focus)=\"handleFocus()\"\n                (blur)=\"handleBlur()\"\n            >{{localization.get('cancel')}}</button>\n            <button\n                #accept\n                class=\"k-time-accept k-button k-primary\"\n                [attr.title]=\"localization.get('acceptLabel')\"\n                [attr.aria-label]=\"localization.get('acceptLabel')\"\n                (click)=\"handleAccept()\"\n                (focus)=\"handleFocus()\"\n                (blur)=\"handleBlur()\"\n            >{{localization.get('accept')}}</button>\n        </div>\n    "
                },] },
    ];
    /** @nocollapse */
    TimeSelectorComponent.ctorParameters = function () { return [
        { type: LocalizationService, },
        { type: ChangeDetectorRef, },
        { type: ElementRef, },
        { type: IntlService, },
        { type: DOMService, },
        { type: NgZone, },
    ]; };
    TimeSelectorComponent.propDecorators = {
        'accept': [{ type: ViewChild, args: ['accept',] },],
        'cancel': [{ type: ViewChild, args: ['cancel',] },],
        'now': [{ type: ViewChild, args: ['now',] },],
        'timeLists': [{ type: ViewChildren, args: [TimeListComponent,] },],
        'format': [{ type: Input },],
        'min': [{ type: Input },],
        'max': [{ type: Input },],
        'cancelButton': [{ type: Input },],
        'nowButton': [{ type: Input },],
        'steps': [{ type: Input },],
        'value': [{ type: Input },],
        'valueChange': [{ type: Output },],
        'valueReject': [{ type: Output },],
        'onFocus': [{ type: Output, args: ['focus',] },],
        'onBlur': [{ type: Output, args: ['blur',] },],
        'componentClass': [{ type: HostBinding, args: ['class.k-timeselector',] },],
        'handleKeydown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
    };
    return TimeSelectorComponent;
}());
export { TimeSelectorComponent };
