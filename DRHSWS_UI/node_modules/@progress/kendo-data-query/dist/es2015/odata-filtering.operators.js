import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';
import { compose, either } from './funcs';
import { formatDate, normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue } from './filter-serialization.common';
const fnFormatter = operator => ({ field, value }) => `${operator}(${field},${value})`;
const singleOperatorFormatter = operator => ({ field, value }) => `${field} ${operator} ${value}`;
const stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);
const stringFnOperator = operator => stringFormat(fnFormatter(operator));
const stringOperator = operator => stringFormat(singleOperatorFormatter(operator));
const numericOperator = operator => compose(singleOperatorFormatter(operator), normalizeField);
const dateOperator = operator => compose(singleOperatorFormatter(operator), normalizeField, formatDate);
const ifDate = operator => either(isDateValue, dateOperator(operator), numericOperator(operator));
const typedOperator = operator => either(isStringValue, stringOperator(operator), ifDate(operator));
const appendEqual = str => `${str} eq -1`;
const nonValueExpression = formatter => compose(formatter, normalizeField);
const filterOperators = {
    contains: stringFnOperator("contains"),
    doesnotcontain: compose(appendEqual, stringFnOperator("indexof")),
    endswith: stringFnOperator("endswith"),
    eq: typedOperator("eq"),
    gt: typedOperator("gt"),
    gte: typedOperator("ge"),
    isempty: nonValueExpression(({ field }) => `${field} eq ''`),
    isnotempty: nonValueExpression(({ field }) => `${field} ne ''`),
    isnotnull: nonValueExpression(({ field }) => `${field} ne null`),
    isnull: nonValueExpression(({ field }) => `${field} eq null`),
    lt: typedOperator("lt"),
    lte: typedOperator("le"),
    neq: typedOperator("ne"),
    startswith: stringFnOperator("startswith")
};
const join = x => ` ${x.logic} `;
const serialize = x => filterOperators[x.operator](x);
const serializeAll = serializeFilters(filter => either(isCompositeFilterDescriptor, serializeAll, serialize)(filter), join);
/**
 * @hidden
 */
export const serializeFilter = (filter) => {
    if (filter.filters && filter.filters.length) {
        return "$filter=" + serializeAll(filter);
    }
    return "";
};
