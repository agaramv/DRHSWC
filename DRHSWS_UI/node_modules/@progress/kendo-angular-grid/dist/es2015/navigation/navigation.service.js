import { EventEmitter, Injectable, NgZone, ChangeDetectorRef } from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { from } from 'rxjs/observable/from';
import { filter } from 'rxjs/operators/filter';
import { interval } from 'rxjs/observable/interval';
import { switchMap } from 'rxjs/operators/switchMap';
import { switchMapTo } from 'rxjs/operators/switchMapTo';
import { take } from 'rxjs/operators/take';
import { takeUntil } from 'rxjs/operators/takeUntil';
import { DomEventsService } from '../common/dom-events.service';
import { GroupsService } from '../grouping/groups.service';
import { PagerContextService } from '../pager/pager-context.service';
import { closest, closestInScope, contains, findFocusableChild, isVisible, matchesNodeName } from '../rendering/common/dom-queries';
import { CellKeydownEvent } from './cell-keydown-event';
import { FocusRoot } from './focus-root';
import { NavigationCursor } from './navigation-cursor';
import { NavigationModel } from './navigation-model';
import { ScrollRequestService } from '../scrolling/scroll-request.service';
import { EditService } from '../editing/edit.service';
import { LocalizationService } from '@progress/kendo-angular-l10n';
const targetCell = (target) => {
    const table = closest(target, matchesNodeName('table'));
    const heading = closestInScope(target, matchesNodeName('th'), table);
    const cell = closestInScope(target, matchesNodeName('td'), table) || heading;
    const row = closestInScope(cell, matchesNodeName('tr'), table);
    if (cell && row) {
        let rowIndex = row.getAttribute('aria-rowindex');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
        let colIndex = cell.getAttribute('aria-colindex');
        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
        if (rowIndex !== null && colIndex !== null) {
            return { colIndex, rowIndex, element: cell };
        }
    }
};
const lastCell = (row) => {
    const cells = row.cells;
    return cells[cells.length - 1];
};
const isArrowKey = keyCode => keyCode === 37 /* left */ || keyCode === 39 /* right */ ||
    keyCode === 38 /* up */ || keyCode === 40 /* down */;
const isNavigationKey = keyCode => isArrowKey(keyCode) ||
    keyCode === 33 /* page_up */ || keyCode === 34 /* page_down */ ||
    keyCode === 36 /* home */ || keyCode === 35 /* end */;
const isInput = matchesNodeName('input');
const isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';
const isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
/**
 * @hidden
 */
export class NavigationViewport {
    constructor(firstItemIndex, lastItemIndex) {
        this.firstItemIndex = firstItemIndex;
        this.lastItemIndex = lastItemIndex;
    }
    containsRow(dataRowIndex) {
        const headerRow = dataRowIndex < 0;
        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex < this.lastItemIndex);
    }
}
/**
 * @hidden
 */
export class NavigationService {
    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, focusRoot, editService, cd, localization) {
        this.zone = zone;
        this.domEvents = domEvents;
        this.pagerContextService = pagerContextService;
        this.scrollRequestService = scrollRequestService;
        this.groupsService = groupsService;
        this.focusRoot = focusRoot;
        this.editService = editService;
        this.cd = cd;
        this.localization = localization;
        this.cellKeydown = new EventEmitter();
        this.activeRowIndex = 0;
        this.alive = false;
        this.mode = 0 /* Standby */;
        this.model = new NavigationModel();
        this.cursor = new NavigationCursor(this.model);
        this.changes = this.cursor.changes;
    }
    set metadata(value) {
        this.meta = value;
        this.cursor.metadata = value;
    }
    get metadata() {
        return this.meta;
    }
    get enabled() {
        return this.alive;
    }
    get activeCell() {
        if (this.mode !== 0 /* Standby */) {
            return this.cursor.cell;
        }
    }
    get activeRow() {
        if (this.mode !== 0 /* Standby */) {
            return this.cursor.row;
        }
    }
    get activeDataRow() {
        return this.activeRowIndex - this.meta.headerRows;
    }
    init(meta) {
        this.alive = true;
        this.metadata = meta;
        const onStable = () => this.zone.isStable ?
            from([true]) :
            this.zone.onStable.pipe(take(1));
        this.subs = new Subscription();
        this.subs.add(this.cursor.changes
            .subscribe(args => this.onCursorChanges(args)));
        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable, args => args))
            .subscribe(args => this.navigateTo(args.target)));
        this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* Standby */), switchMap(onStable, args => args))
            .subscribe(args => this.onFocusOut(args)));
        this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* Standby */))
            .subscribe(() => this.onWindowBlur()));
        this.subs.add(
        // Closing the editor will not always trigger focusout in Firefox.
        // To get around this, we ensure that the cell is closed after editing.
        this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2 /* Content */), filter((e) => e.action === 'cellClose' && !e.prevented), switchMap(onStable, args => args))
            .subscribe(() => this.leaveCell()));
        this.subs.add(this.pagerContextService.pageChange
            .subscribe(() => this.cursor.reset(0, 0)));
        this.subs.add(this.domEvents.keydown
            .subscribe(args => this.onKeydown(args)));
        this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === 9 /* tab */ && this.mode === 2 /* Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
        // Timeout if focusOut doesn't fire very soon
        interval(0).pipe(take(1))))))
            .subscribe(() => this.onTabout()));
        this.deactivateElements();
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        this.alive = false;
    }
    registerCell(cell) {
        if (cell.logicalRowIndex !== this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    }
    registerCellOnCurrentRow(cell) {
        if (cell.logicalRowIndex === this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    }
    registerRow(row) {
        this.model.registerRow(row);
        this.pendingRowIndex = row.logicalRowIndex;
    }
    unregisterRow(row) {
        this.model.unregisterRow(row);
    }
    isCellFocusable(cell) {
        return this.alive && this.mode !== 2 /* Content */ && this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);
    }
    isCellFocused(cell) {
        return this.mode === 1 /* Cursor */ && this.isCellFocusable(cell);
    }
    navigateTo(el) {
        if (!this.alive) {
            return;
        }
        const cell = targetCell(el);
        if (!cell) {
            return;
        }
        const oldMode = this.mode;
        const focusInCell = contains(cell.element, document.activeElement);
        const focusInActiveRowContent = this.mode === 2 /* Content */ &&
            this.activeRowIndex === cell.rowIndex &&
            el !== cell.element;
        if (focusInCell) {
            this.mode = 2 /* Content */;
            this.cursor.reset(cell.rowIndex, cell.colIndex);
            this.activateRow();
        }
        else if (!focusInActiveRowContent) {
            this.mode = 1 /* Cursor */;
            this.deactivateElements();
            const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);
            const isCursor = oldMode === 1 /* Cursor */ && alreadyActive;
            if (!isCursor) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
            }
        }
    }
    tryFocus(el) {
        this.activateElements();
        const focusable = findFocusableChild(el);
        if (focusable) {
            const cell = targetCell(focusable);
            if (cell) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
                this.deactivateElements();
                this.enterCell();
            }
            focusable.focus();
        }
        else {
            this.deactivateElements();
        }
        return !!focusable;
    }
    needsViewport() {
        return this.meta && this.meta.isVirtual;
    }
    setViewport(firstItemIndex, lastItemIndex) {
        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && lastItemIndex > 0) {
            const dataRowIndex = Math.max(0, this.activeRowIndex - this.meta.headerRows);
            const ahead = firstItemIndex - dataRowIndex;
            const behind = dataRowIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(firstItemIndex + this.meta.headerRows + 1);
            }
            else if (behind > 0) {
                this.cursor.reset(lastItemIndex + this.meta.headerRows - 1);
            }
        }
    }
    focusCell(rowIndex = undefined, colIndex = undefined) {
        this.mode = 1 /* Cursor */;
        this.cursor.reset(rowIndex, colIndex);
        return this.activeCell;
    }
    focusNextCell(wrap = true) {
        return this.focusAdjacentCell(true, wrap);
    }
    focusPrevCell(wrap = true) {
        return this.focusAdjacentCell(false, wrap);
    }
    focusAdjacentCell(fwd, wrap) {
        this.focusCell();
        let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
        if (wrap && !success) {
            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
            if (success) {
                const row = this.cursor.row;
                const cells = row.cells;
                const nextCell = cells[fwd ? 0 : cells.length - 1];
                this.cursor.reset(row.index, nextCell.colIndex);
            }
        }
        if (success) {
            return this.activeCell;
        }
        else {
            this.mode = 0 /* Standby */;
            this.cursor.announce();
        }
        return null;
    }
    enterCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        this.mode = focusable ? 2 /* Content */ : 1 /* Cursor */;
        this.cursor.announce();
        if (focusable) {
            this.activateRow();
            group.focus();
        }
    }
    leaveCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        if (!focusable) {
            this.deactivateElements();
        }
        this.mode = 1 /* Cursor */;
        this.cursor.announce();
    }
    activateElements() {
        this.focusRoot.activate();
    }
    deactivateElements() {
        this.focusRoot.deactivate();
    }
    activateRow() {
        this.cursor.row.cells
            .forEach(cell => cell.focusGroup && cell.focusGroup.activate());
    }
    moveCursorFwd() {
        return this.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
    }
    moveCursorBwd() {
        return this.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
    }
    onCursorKeydown(args) {
        let preventDefault = false;
        const modifier = args.ctrlKey || args.metaKey;
        const step = modifier ? 5 : 1;
        if (!this.onCellKeydown(args)) {
            return;
        }
        switch (args.keyCode) {
            case 40 /* down */:
                preventDefault = this.cursor.moveDown(step);
                break;
            case 38 /* up */:
                preventDefault = this.cursor.moveUp(step);
                break;
            case 39 /* right */:
                preventDefault = this.moveCursorFwd();
                break;
            case 37 /* left */:
                preventDefault = this.moveCursorBwd();
                break;
            case 34 /* page_down */:
                if (this.metadata.isVirtual && this.viewport) {
                    this.cursor.reset(this.viewport.lastItemIndex + this.meta.headerRows);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.nextPage());
                    preventDefault = true;
                }
                break;
            case 33 /* page_up */:
                if (this.metadata.isVirtual && this.viewport) {
                    const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
                    const nextItemIndex = Math.max(0, this.viewport.firstItemIndex - viewportSize);
                    this.cursor.reset(nextItemIndex + this.meta.headerRows);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.prevPage());
                    preventDefault = true;
                }
                break;
            case 36 /* home */:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        this.cursor.reset(this.meta.headerRows, 0);
                    }
                    else {
                        this.cursor.reset(this.model.firstRow.index, 0);
                    }
                }
                else {
                    const row = this.cursor.row;
                    const cells = row.cells;
                    const firstCell = cells[0];
                    this.cursor.reset(row.index, firstCell.colIndex);
                }
                preventDefault = true;
                break;
            case 35 /* end */:
                if (modifier) {
                    const colIndex = lastCell(this.model.lastRow).colIndex;
                    if (this.meta.isVirtual) {
                        const lastRowIndex = this.meta.dataRows - 1;
                        this.cursor.reset(this.meta.headerRows + lastRowIndex, colIndex);
                    }
                    else {
                        this.cursor.reset(this.model.lastRow.index, colIndex);
                    }
                }
                else {
                    const row = this.cursor.row;
                    const colIndex = lastCell(row).colIndex;
                    this.cursor.reset(row.index, colIndex);
                }
                preventDefault = true;
                break;
            case 13 /* enter */:
            case 113 /* f2 */:
                const groupItem = this.cursor.row.groupItem;
                if (groupItem) {
                    this.zone.run(() => this.groupsService.toggleRow(groupItem.index, groupItem.data));
                }
                else {
                    this.enterCell();
                    if (!this.cursor.cell.focusGroup.isNavigable()) {
                        preventDefault = true;
                    }
                }
                break;
            default:
                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
                    this.enterCell();
                }
        }
        if (preventDefault) {
            args.preventDefault();
        }
    }
    onContentKeydown(args) {
        if (!this.onCellKeydown(args)) {
            return;
        }
        const confirm = !args.defaultPrevented && args.keyCode === 13 /* enter */ && isTextInput(args.srcElement);
        if (args.keyCode === 27 /* esc */ || args.keyCode === 113 /* f2 */ || confirm) {
            this.leaveCell();
            this.cursor.reset();
        }
        else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
            this.onCursorKeydown(args);
            if (args.defaultPrevented) {
                this.leaveCell();
            }
        }
    }
    onCellKeydown(args) {
        if (this.editService.isEditingCell()) {
            const confirm = args.keyCode === 13 /* enter */;
            const cancel = args.keyCode === 27 /* esc */;
            const navigate = isNavigationKey(args.keyCode);
            if (confirm) {
                this.editService.closeCell(args);
            }
            else if (cancel) {
                this.editService.cancelCell();
                this.cd.detectChanges();
            }
            else if (navigate) {
                return false;
            }
        }
        this.cellKeydown.emit(new CellKeydownEvent(args));
        return true;
    }
    onCursorChanges(args) {
        this.activeRowIndex = args.rowIndex;
        // TODO: Use args.dataRowIndex instead of this.activeDataRow
        if (this.meta && this.meta.isVirtual &&
            this.viewport && !this.viewport.containsRow(this.activeDataRow)) {
            this.scrollRequestService.scrollTo(this.activeDataRow);
        }
    }
    onFocusOut(args) {
        if (isVisible(args.target)) {
            this.mode = 0 /* Standby */;
        }
        else {
            // Focused target is no longer visible,
            // reset to cursor mode and recapture focus.
            this.mode = 1 /* Cursor */;
        }
        this.deactivateElements();
        this.cursor.announce();
    }
    onWindowBlur() {
        this.mode = 0 /* Standby */;
        this.deactivateElements();
        this.cursor.announce();
    }
    onKeydown(args) {
        if (this.mode === 1 /* Cursor */) {
            this.onCursorKeydown(args);
        }
        else if (this.mode === 2 /* Content */) {
            this.onContentKeydown(args);
        }
    }
    onTabout() {
        // Tabbed out of the last focusable content element
        // reset to cursor mode and recapture focus.
        if (this.cursor.cell.focusGroup.isNavigable()) {
            // Unless the cell has a single focusable element,
            // otherwise we'd return to Content mode and enter an endless loop
            return;
        }
        this.leaveCell();
        this.cursor.reset();
    }
}
NavigationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: NgZone, },
    { type: DomEventsService, },
    { type: PagerContextService, },
    { type: ScrollRequestService, },
    { type: GroupsService, },
    { type: FocusRoot, },
    { type: EditService, },
    { type: ChangeDetectorRef, },
    { type: LocalizationService, },
];
