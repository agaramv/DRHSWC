import { EventEmitter, Injectable, NgZone, ChangeDetectorRef } from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { from } from 'rxjs/observable/from';
import { filter } from 'rxjs/operators/filter';
import { interval } from 'rxjs/observable/interval';
import { switchMap } from 'rxjs/operators/switchMap';
import { switchMapTo } from 'rxjs/operators/switchMapTo';
import { take } from 'rxjs/operators/take';
import { takeUntil } from 'rxjs/operators/takeUntil';
import { DomEventsService } from '../common/dom-events.service';
import { GroupsService } from '../grouping/groups.service';
import { PagerContextService } from '../pager/pager-context.service';
import { closest, closestInScope, contains, findFocusableChild, isVisible, matchesNodeName } from '../rendering/common/dom-queries';
import { CellKeydownEvent } from './cell-keydown-event';
import { FocusRoot } from './focus-root';
import { NavigationCursor } from './navigation-cursor';
import { NavigationModel } from './navigation-model';
import { ScrollRequestService } from '../scrolling/scroll-request.service';
import { EditService } from '../editing/edit.service';
import { LocalizationService } from '@progress/kendo-angular-l10n';
var targetCell = function (target) {
    var table = closest(target, matchesNodeName('table'));
    var heading = closestInScope(target, matchesNodeName('th'), table);
    var cell = closestInScope(target, matchesNodeName('td'), table) || heading;
    var row = closestInScope(cell, matchesNodeName('tr'), table);
    if (cell && row) {
        var rowIndex = row.getAttribute('aria-rowindex');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
        var colIndex = cell.getAttribute('aria-colindex');
        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
        if (rowIndex !== null && colIndex !== null) {
            return { colIndex: colIndex, rowIndex: rowIndex, element: cell };
        }
    }
};
var lastCell = function (row) {
    var cells = row.cells;
    return cells[cells.length - 1];
};
var isArrowKey = function (keyCode) {
    return keyCode === 37 /* left */ || keyCode === 39 /* right */ ||
        keyCode === 38 /* up */ || keyCode === 40 /* down */;
};
var isNavigationKey = function (keyCode) {
    return isArrowKey(keyCode) ||
        keyCode === 33 /* page_up */ || keyCode === 34 /* page_down */ ||
        keyCode === 36 /* home */ || keyCode === 35 /* end */;
};
var isInput = matchesNodeName('input');
var isTextInput = function (element) {
    return element && isInput(element) && element.type.toLowerCase() === 'text';
};
var isPrintableCharacter = function (str) {
    return str.length === 1 && str.match(/\S/);
};
/**
 * @hidden
 */
var NavigationViewport = /** @class */ (function () {
    function NavigationViewport(firstItemIndex, lastItemIndex) {
        this.firstItemIndex = firstItemIndex;
        this.lastItemIndex = lastItemIndex;
    }
    NavigationViewport.prototype.containsRow = function (dataRowIndex) {
        var headerRow = dataRowIndex < 0;
        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex < this.lastItemIndex);
    };
    return NavigationViewport;
}());
export { NavigationViewport };
/**
 * @hidden
 */
var NavigationService = /** @class */ (function () {
    function NavigationService(zone, domEvents, pagerContextService, scrollRequestService, groupsService, focusRoot, editService, cd, localization) {
        this.zone = zone;
        this.domEvents = domEvents;
        this.pagerContextService = pagerContextService;
        this.scrollRequestService = scrollRequestService;
        this.groupsService = groupsService;
        this.focusRoot = focusRoot;
        this.editService = editService;
        this.cd = cd;
        this.localization = localization;
        this.cellKeydown = new EventEmitter();
        this.activeRowIndex = 0;
        this.alive = false;
        this.mode = 0 /* Standby */;
        this.model = new NavigationModel();
        this.cursor = new NavigationCursor(this.model);
        this.changes = this.cursor.changes;
    }
    Object.defineProperty(NavigationService.prototype, "metadata", {
        get: function () {
            return this.meta;
        },
        set: function (value) {
            this.meta = value;
            this.cursor.metadata = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "enabled", {
        get: function () {
            return this.alive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "activeCell", {
        get: function () {
            if (this.mode !== 0 /* Standby */) {
                return this.cursor.cell;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "activeRow", {
        get: function () {
            if (this.mode !== 0 /* Standby */) {
                return this.cursor.row;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "activeDataRow", {
        get: function () {
            return this.activeRowIndex - this.meta.headerRows;
        },
        enumerable: true,
        configurable: true
    });
    NavigationService.prototype.init = function (meta) {
        var _this = this;
        this.alive = true;
        this.metadata = meta;
        var onStable = function () { return _this.zone.isStable ?
            from([true]) :
            _this.zone.onStable.pipe(take(1)); };
        this.subs = new Subscription();
        this.subs.add(this.cursor.changes
            .subscribe(function (args) { return _this.onCursorChanges(args); }));
        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable, function (args) { return args; }))
            .subscribe(function (args) { return _this.navigateTo(args.target); }));
        this.subs.add(this.domEvents.focusOut.pipe(filter(function () { return _this.mode !== 0 /* Standby */; }), switchMap(onStable, function (args) { return args; }))
            .subscribe(function (args) { return _this.onFocusOut(args); }));
        this.subs.add(this.domEvents.windowBlur.pipe(filter(function () { return _this.mode !== 0 /* Standby */; }))
            .subscribe(function () { return _this.onWindowBlur(); }));
        this.subs.add(
        // Closing the editor will not always trigger focusout in Firefox.
        // To get around this, we ensure that the cell is closed after editing.
        this.editService.changes.pipe(filter(function (e) { return e.action !== 'edit' && _this.mode === 2 /* Content */; }), filter(function (e) { return e.action === 'cellClose' && !e.prevented; }), switchMap(onStable, function (args) { return args; }))
            .subscribe(function () { return _this.leaveCell(); }));
        this.subs.add(this.pagerContextService.pageChange
            .subscribe(function () { return _this.cursor.reset(0, 0); }));
        this.subs.add(this.domEvents.keydown
            .subscribe(function (args) { return _this.onKeydown(args); }));
        this.subs.add(this.domEvents.keydown.pipe(filter(function (args) {
            return args.keyCode === 9 /* tab */ && _this.mode === 2 /* Content */;
        }), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
        // Timeout if focusOut doesn't fire very soon
        interval(0).pipe(take(1))))))
            .subscribe(function () { return _this.onTabout(); }));
        this.deactivateElements();
    };
    NavigationService.prototype.ngOnDestroy = function () {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        this.alive = false;
    };
    NavigationService.prototype.registerCell = function (cell) {
        if (cell.logicalRowIndex !== this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    };
    NavigationService.prototype.registerCellOnCurrentRow = function (cell) {
        if (cell.logicalRowIndex === this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    };
    NavigationService.prototype.registerRow = function (row) {
        this.model.registerRow(row);
        this.pendingRowIndex = row.logicalRowIndex;
    };
    NavigationService.prototype.unregisterRow = function (row) {
        this.model.unregisterRow(row);
    };
    NavigationService.prototype.isCellFocusable = function (cell) {
        return this.alive && this.mode !== 2 /* Content */ && this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);
    };
    NavigationService.prototype.isCellFocused = function (cell) {
        return this.mode === 1 /* Cursor */ && this.isCellFocusable(cell);
    };
    NavigationService.prototype.navigateTo = function (el) {
        if (!this.alive) {
            return;
        }
        var cell = targetCell(el);
        if (!cell) {
            return;
        }
        var oldMode = this.mode;
        var focusInCell = contains(cell.element, document.activeElement);
        var focusInActiveRowContent = this.mode === 2 /* Content */ &&
            this.activeRowIndex === cell.rowIndex &&
            el !== cell.element;
        if (focusInCell) {
            this.mode = 2 /* Content */;
            this.cursor.reset(cell.rowIndex, cell.colIndex);
            this.activateRow();
        }
        else if (!focusInActiveRowContent) {
            this.mode = 1 /* Cursor */;
            this.deactivateElements();
            var alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);
            var isCursor = oldMode === 1 /* Cursor */ && alreadyActive;
            if (!isCursor) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
            }
        }
    };
    NavigationService.prototype.tryFocus = function (el) {
        this.activateElements();
        var focusable = findFocusableChild(el);
        if (focusable) {
            var cell = targetCell(focusable);
            if (cell) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
                this.deactivateElements();
                this.enterCell();
            }
            focusable.focus();
        }
        else {
            this.deactivateElements();
        }
        return !!focusable;
    };
    NavigationService.prototype.needsViewport = function () {
        return this.meta && this.meta.isVirtual;
    };
    NavigationService.prototype.setViewport = function (firstItemIndex, lastItemIndex) {
        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && lastItemIndex > 0) {
            var dataRowIndex = Math.max(0, this.activeRowIndex - this.meta.headerRows);
            var ahead = firstItemIndex - dataRowIndex;
            var behind = dataRowIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(firstItemIndex + this.meta.headerRows + 1);
            }
            else if (behind > 0) {
                this.cursor.reset(lastItemIndex + this.meta.headerRows - 1);
            }
        }
    };
    NavigationService.prototype.focusCell = function (rowIndex, colIndex) {
        if (rowIndex === void 0) { rowIndex = undefined; }
        if (colIndex === void 0) { colIndex = undefined; }
        this.mode = 1 /* Cursor */;
        this.cursor.reset(rowIndex, colIndex);
        return this.activeCell;
    };
    NavigationService.prototype.focusNextCell = function (wrap) {
        if (wrap === void 0) { wrap = true; }
        return this.focusAdjacentCell(true, wrap);
    };
    NavigationService.prototype.focusPrevCell = function (wrap) {
        if (wrap === void 0) { wrap = true; }
        return this.focusAdjacentCell(false, wrap);
    };
    NavigationService.prototype.focusAdjacentCell = function (fwd, wrap) {
        this.focusCell();
        var success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
        if (wrap && !success) {
            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
            if (success) {
                var row = this.cursor.row;
                var cells = row.cells;
                var nextCell = cells[fwd ? 0 : cells.length - 1];
                this.cursor.reset(row.index, nextCell.colIndex);
            }
        }
        if (success) {
            return this.activeCell;
        }
        else {
            this.mode = 0 /* Standby */;
            this.cursor.announce();
        }
        return null;
    };
    NavigationService.prototype.enterCell = function () {
        var cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        var group = cell.focusGroup;
        var focusable = group && group.canFocus();
        this.mode = focusable ? 2 /* Content */ : 1 /* Cursor */;
        this.cursor.announce();
        if (focusable) {
            this.activateRow();
            group.focus();
        }
    };
    NavigationService.prototype.leaveCell = function () {
        var cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        var group = cell.focusGroup;
        var focusable = group && group.canFocus();
        if (!focusable) {
            this.deactivateElements();
        }
        this.mode = 1 /* Cursor */;
        this.cursor.announce();
    };
    NavigationService.prototype.activateElements = function () {
        this.focusRoot.activate();
    };
    NavigationService.prototype.deactivateElements = function () {
        this.focusRoot.deactivate();
    };
    NavigationService.prototype.activateRow = function () {
        this.cursor.row.cells
            .forEach(function (cell) { return cell.focusGroup && cell.focusGroup.activate(); });
    };
    NavigationService.prototype.moveCursorFwd = function () {
        return this.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
    };
    NavigationService.prototype.moveCursorBwd = function () {
        return this.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
    };
    NavigationService.prototype.onCursorKeydown = function (args) {
        var _this = this;
        var preventDefault = false;
        var modifier = args.ctrlKey || args.metaKey;
        var step = modifier ? 5 : 1;
        if (!this.onCellKeydown(args)) {
            return;
        }
        switch (args.keyCode) {
            case 40 /* down */:
                preventDefault = this.cursor.moveDown(step);
                break;
            case 38 /* up */:
                preventDefault = this.cursor.moveUp(step);
                break;
            case 39 /* right */:
                preventDefault = this.moveCursorFwd();
                break;
            case 37 /* left */:
                preventDefault = this.moveCursorBwd();
                break;
            case 34 /* page_down */:
                if (this.metadata.isVirtual && this.viewport) {
                    this.cursor.reset(this.viewport.lastItemIndex + this.meta.headerRows);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(function () { return _this.pagerContextService.nextPage(); });
                    preventDefault = true;
                }
                break;
            case 33 /* page_up */:
                if (this.metadata.isVirtual && this.viewport) {
                    var viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
                    var nextItemIndex = Math.max(0, this.viewport.firstItemIndex - viewportSize);
                    this.cursor.reset(nextItemIndex + this.meta.headerRows);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(function () { return _this.pagerContextService.prevPage(); });
                    preventDefault = true;
                }
                break;
            case 36 /* home */:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        this.cursor.reset(this.meta.headerRows, 0);
                    }
                    else {
                        this.cursor.reset(this.model.firstRow.index, 0);
                    }
                }
                else {
                    var row = this.cursor.row;
                    var cells = row.cells;
                    var firstCell = cells[0];
                    this.cursor.reset(row.index, firstCell.colIndex);
                }
                preventDefault = true;
                break;
            case 35 /* end */:
                if (modifier) {
                    var colIndex = lastCell(this.model.lastRow).colIndex;
                    if (this.meta.isVirtual) {
                        var lastRowIndex = this.meta.dataRows - 1;
                        this.cursor.reset(this.meta.headerRows + lastRowIndex, colIndex);
                    }
                    else {
                        this.cursor.reset(this.model.lastRow.index, colIndex);
                    }
                }
                else {
                    var row = this.cursor.row;
                    var colIndex = lastCell(row).colIndex;
                    this.cursor.reset(row.index, colIndex);
                }
                preventDefault = true;
                break;
            case 13 /* enter */:
            case 113 /* f2 */:
                var groupItem_1 = this.cursor.row.groupItem;
                if (groupItem_1) {
                    this.zone.run(function () {
                        return _this.groupsService.toggleRow(groupItem_1.index, groupItem_1.data);
                    });
                }
                else {
                    this.enterCell();
                    if (!this.cursor.cell.focusGroup.isNavigable()) {
                        preventDefault = true;
                    }
                }
                break;
            default:
                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
                    this.enterCell();
                }
        }
        if (preventDefault) {
            args.preventDefault();
        }
    };
    NavigationService.prototype.onContentKeydown = function (args) {
        if (!this.onCellKeydown(args)) {
            return;
        }
        var confirm = !args.defaultPrevented && args.keyCode === 13 /* enter */ && isTextInput(args.srcElement);
        if (args.keyCode === 27 /* esc */ || args.keyCode === 113 /* f2 */ || confirm) {
            this.leaveCell();
            this.cursor.reset();
        }
        else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
            this.onCursorKeydown(args);
            if (args.defaultPrevented) {
                this.leaveCell();
            }
        }
    };
    NavigationService.prototype.onCellKeydown = function (args) {
        if (this.editService.isEditingCell()) {
            var confirm_1 = args.keyCode === 13 /* enter */;
            var cancel = args.keyCode === 27 /* esc */;
            var navigate = isNavigationKey(args.keyCode);
            if (confirm_1) {
                this.editService.closeCell(args);
            }
            else if (cancel) {
                this.editService.cancelCell();
                this.cd.detectChanges();
            }
            else if (navigate) {
                return false;
            }
        }
        this.cellKeydown.emit(new CellKeydownEvent(args));
        return true;
    };
    NavigationService.prototype.onCursorChanges = function (args) {
        this.activeRowIndex = args.rowIndex;
        // TODO: Use args.dataRowIndex instead of this.activeDataRow
        if (this.meta && this.meta.isVirtual &&
            this.viewport && !this.viewport.containsRow(this.activeDataRow)) {
            this.scrollRequestService.scrollTo(this.activeDataRow);
        }
    };
    NavigationService.prototype.onFocusOut = function (args) {
        if (isVisible(args.target)) {
            this.mode = 0 /* Standby */;
        }
        else {
            // Focused target is no longer visible,
            // reset to cursor mode and recapture focus.
            this.mode = 1 /* Cursor */;
        }
        this.deactivateElements();
        this.cursor.announce();
    };
    NavigationService.prototype.onWindowBlur = function () {
        this.mode = 0 /* Standby */;
        this.deactivateElements();
        this.cursor.announce();
    };
    NavigationService.prototype.onKeydown = function (args) {
        if (this.mode === 1 /* Cursor */) {
            this.onCursorKeydown(args);
        }
        else if (this.mode === 2 /* Content */) {
            this.onContentKeydown(args);
        }
    };
    NavigationService.prototype.onTabout = function () {
        // Tabbed out of the last focusable content element
        // reset to cursor mode and recapture focus.
        if (this.cursor.cell.focusGroup.isNavigable()) {
            // Unless the cell has a single focusable element,
            // otherwise we'd return to Content mode and enter an endless loop
            return;
        }
        this.leaveCell();
        this.cursor.reset();
    };
    NavigationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NavigationService.ctorParameters = function () { return [
        { type: NgZone, },
        { type: DomEventsService, },
        { type: PagerContextService, },
        { type: ScrollRequestService, },
        { type: GroupsService, },
        { type: FocusRoot, },
        { type: EditService, },
        { type: ChangeDetectorRef, },
        { type: LocalizationService, },
    ]; };
    return NavigationService;
}());
export { NavigationService };
