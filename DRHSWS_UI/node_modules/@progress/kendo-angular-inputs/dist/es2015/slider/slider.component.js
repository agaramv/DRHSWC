import { Renderer2, Component, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, ViewChild, forwardRef, ContentChild } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subscription } from 'rxjs/Subscription';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { interval } from 'rxjs/observable/interval';
import { merge } from 'rxjs/observable/merge';
import { filter } from 'rxjs/operators/filter';
import { concatMap } from 'rxjs/operators/concatMap';
import { startWith } from 'rxjs/operators/startWith';
import { takeUntil } from 'rxjs/operators/takeUntil';
import { SliderUtil as Util } from '@telerik/kendo-inputs-common';
import { SliderModel } from './slider-model';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { LabelTemplateDirective } from './label-template.directive';
import { Keys } from '../common/enums';
import { isChanged } from '../common/changes';
import { areSame } from '../common/utils';
import { isButton, eventValue, decreaseValueToStep, increaseValueToStep, increment, decrement, incrementLarge, decrementLarge } from './utils';
import { guid, isDocumentAvailable } from '../common/dom-utils';
/**
 * Represents the Kendo UI Slider component for Angular ([see example]({ slug overview_slider %})).
 */
export class SliderComponent {
    constructor(localizationService, renderer, hostElement) {
        this.localizationService = localizationService;
        this.renderer = renderer;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Makes the arrow side buttons of the Slider appear. When `showButtons` is set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * Denotes the location of the tick marks in the Slider.
         *
         * The available options are:
         * * `before`&mdash;Tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
         * * `after`&mdash;Tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
         * * `both`&mdash;Tick marks are located on both sides of the track.
         * * `none`&mdash;Tick marks are not visible. The actual elements are not added to the DOM tree.
         */
        this.tickPlacement = 'both';
        /**
         * Defines the title of the ticks. The default title for each tick is its Slider value.
         * If you use a callback function, the function accepts an argument that holds the value of
         * the component and returns a string with the new title.
         */
        this.title = Util.identity;
        /**
         * If `vertical` is set to `true`, it changes the orientation of the Slider from horizontal to vertical.
         */
        this.vertical = false;
        /**
         * The minimum value of the Slider. The attribute accepts both integers and floating-point numbers.
         */
        this.min = 0;
        /**
         * The maximum value of the Slider. The attribute accepts both integers and floating-point numbers.
         */
        this.max = 10;
        /**
         * The step value of the Slider. Accepts positive values only.
         * Can be both integer or a floating-point number.
         */
        this.smallStep = 1;
        /**
         * Specifies that every n<sup>th</sup> tick will be large and will have a label.
         * Accepts positive integer values only.
         */
        this.largeStep = null;
        /**
         * Determines whether the component is disabled.
         */
        this.disabled = false;
        /**
         * Determines whether the Slider is in its read-only state.
         */
        this.readonly = false;
        /**
         * The current value of the Slider when it is initially displayed.
         * The component can use either NgModel or the `value` binging, but not both of them at the same time.
         */
        this.value = 0;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.dragging = false;
        /**
         * @hidden
         */
        this.ifEnabled = (callback, event) => {
            if (this.disabled || this.readonly) {
                return;
            }
            callback.call(this, event);
        };
        this.decreaseButtonSubscription = Subscription.EMPTY;
        this.increaseButtonSubscription = Subscription.EMPTY;
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.decreaseValue = () => {
            this.changeValue(decreaseValueToStep(this.value, this.getProps()));
        };
        this.increaseValue = () => {
            this.changeValue(increaseValueToStep(this.value, this.getProps()));
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
        this.hostElement = hostElement.nativeElement;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get horizontalClass() {
        return !this.vertical;
    }
    get verticalClass() {
        return this.vertical;
    }
    get sliderClass() {
        return true;
    }
    get transitionsClass() {
        return true;
    }
    get widgetClass() {
        return true;
    }
    get stateDefaultClass() {
        return true;
    }
    get disabledClass() {
        return this.disabled;
    }
    get focusedClass() {
        return this.focused;
    }
    get ariaDisabled() {
        return this.disabled ? true : undefined;
    }
    get ariaReadonly() {
        return this.readonly ? true : undefined;
    }
    get ariaMin() {
        return this.min;
    }
    get ariaMax() {
        return this.max;
    }
    get ariaValue() {
        return this.value ? this.value : this.min;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    handleFocus() {
        this.focused = true;
        this.onFocus.emit();
    }
    /**
     * @hidden
     */
    handleBlur() {
        this.focused = false;
        this.ngTouched();
        this.onBlur.emit();
    }
    /**
     * @hidden
     */
    keydown(event) {
        this.onKeyDown(event);
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.sizeComponent(false);
        });
        this.renderer.removeAttribute(this.hostElement, "tabindex");
    }
    /**
     * Focuses the Slider component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.focus();
    }
    /**
     * Blurs the Slider component.
     */
    blur() {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.blur();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes)) {
            this.sizeComponent(false);
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.increaseButtonSubscription = this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
            this.decreaseButtonSubscription = this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent(false));
        }
    }
    ngOnDestroy() {
        this.decreaseButtonSubscription.unsubscribe();
        this.increaseButtonSubscription.unsubscribe();
        this.localizationChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    get incrementMessage() {
        return this.incrementTitle || this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementMessage() {
        return this.decrementTitle || this.localizationService.get('decrement');
    }
    /**
     * @hidden
     */
    get dragHandleMessage() {
        return this.dragHandleTitle || this.localizationService.get('dragHandle');
    }
    /**
     * @hidden
     */
    onWrapClick(args) {
        const target = args.target;
        if (!(isButton(target) || isButton(target.parentNode))) {
            const value = eventValue(args, this.track.nativeElement, this.getProps());
            this.changeValue(value);
        }
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.focus();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    }
    /**
     * @hidden
     */
    onKeyDown(e) {
        const options = this.getProps();
        const { disabled, max, min, readonly } = options;
        const handler = this.keyBinding[e.keyCode];
        if (disabled || readonly || !handler) {
            return;
        }
        const value = handler(options);
        this.changeValue(Util.trimValue(max, min, value));
        e.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        this.dragging = false; //needed for animation
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.sizeComponent(true);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!areSame(this.value, value)) {
            this.value = value;
            this.ngChange(value);
            this.valueChange.emit(value);
            this.sizeComponent(true);
        }
    }
    /**
     * @hidden
     */
    sizeComponent(animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const props = this.getProps();
        const model = new SliderModel(props, wrapper, this.track.nativeElement);
        model.resizeTrack();
        if (this.ticks) {
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        this.handleAnimation(animate); //first time the widget is initialized the selection should not be animated
        model.positionHandle(this.draghandle.nativeElement);
        model.positionSelection(this.draghandle.nativeElement, this.sliderSelection.nativeElement);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    get reverse() {
        return this.localizationService.rtl && !this.vertical;
    }
    get keyBinding() {
        const reverse = this.reverse;
        return {
            [Keys.left]: reverse ? increment : decrement,
            [Keys.right]: reverse ? decrement : increment,
            [Keys.down]: decrement,
            [Keys.up]: increment,
            [Keys.page_up]: incrementLarge,
            [Keys.page_down]: decrementLarge,
            [Keys.home]: ({ min }) => min,
            [Keys.end]: ({ max }) => max
        };
    }
    setValueChangeInterval(element, callback) {
        const mousedown = fromEvent(element, 'mousedown');
        const mouseup = fromEvent(element, 'mouseup');
        const mouseout = fromEvent(element, 'mouseout');
        const subscription = mousedown.pipe(filter((e) => e.button === 0), filter(() => !this.disabled && !this.readonly), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {
            this.focus();
            callback();
        });
        return subscription;
    }
    handleAnimation(animate) {
        let transition = '';
        if (!animate) {
            transition = 'none';
        }
        this.draghandle.nativeElement.style.transition = transition;
        this.sliderSelection.nativeElement.style.transition = transition;
    }
    getProps() {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: Util.trimValue(this.max, this.min, this.value),
            vertical: this.vertical
        };
    }
}
SliderComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent) } /* tslint:disable-line */
                ],
                selector: 'kendo-slider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >

        <div class="k-slider-wrap" #wrap
            [id]="focusableId"
            [class.k-slider-buttons]="showButtons"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            (click)="ifEnabled(onWrapClick, $event)"
            [attr.tabindex]="(this.disabled ? undefined : tabIndex)"
            (focus)="handleFocus()"
            (blur)="handleBlur()"
            >
            <a
                #decreaseButton
                *ngIf="showButtons"
                class="k-button k-button-decrease"
                [title]="decrementMessage"
                [attr.aria-label]="decrementMessage"
            >
                <span
                    [class.k-icon]="true"
                    [class.k-i-arrow-w]="!vertical"
                    [class.k-i-arrow-s]="vertical"
                >
                </span>
            </a>
            <a
                *ngIf="showButtons"
                #increaseButton
                class="k-button k-button-increase"
                [title]="incrementMessage"
                [attr.aria-label]="incrementMessage"
            >
                <span
                    [class.k-icon]="true"
                    [class.k-i-arrow-e]="!vertical"
                    [class.k-i-arrow-n]="vertical"
                >
                </span>
            </a>
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
            >
            </ul>
        <div #track
            class="k-slider-track"
            >
            <div #sliderSelection
                [class.k-slider-selection]="true"
                [class.k-pressed]="dragging"
                >
            </div>
                <a #draghandle
                    [class.k-draghandle]="true"
                    [class.k-pressed]="dragging"
                    [title]="dragHandleMessage"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                >Drag</a>
            </div>

            <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
        </div>
  `
            },] },
];
/** @nocollapse */
SliderComponent.ctorParameters = () => [
    { type: LocalizationService, },
    { type: Renderer2, },
    { type: ElementRef, },
];
SliderComponent.propDecorators = {
    'focusableId': [{ type: Input },],
    'incrementTitle': [{ type: Input },],
    'decrementTitle': [{ type: Input },],
    'showButtons': [{ type: Input },],
    'tickPlacement': [{ type: Input },],
    'title': [{ type: Input },],
    'dragHandleTitle': [{ type: Input },],
    'vertical': [{ type: Input },],
    'min': [{ type: Input },],
    'max': [{ type: Input },],
    'smallStep': [{ type: Input },],
    'largeStep': [{ type: Input },],
    'fixedTickWidth': [{ type: Input },],
    'disabled': [{ type: Input },],
    'readonly': [{ type: Input },],
    'value': [{ type: Input },],
    'tabindex': [{ type: Input },],
    'tabIndex': [{ type: Input },],
    'onFocus': [{ type: Output, args: ['focus',] },],
    'onBlur': [{ type: Output, args: ['blur',] },],
    'valueChange': [{ type: Output },],
    'wrapper': [{ type: ViewChild, args: ['wrap',] },],
    'track': [{ type: ViewChild, args: ['track',] },],
    'draghandle': [{ type: ViewChild, args: ['draghandle',] },],
    'sliderSelection': [{ type: ViewChild, args: ['sliderSelection',] },],
    'ticksContainer': [{ type: ViewChild, args: ['ticks', { read: ElementRef },] },],
    'ticks': [{ type: ViewChild, args: ['ticks',] },],
    'decreaseButton': [{ type: ViewChild, args: ['decreaseButton',] },],
    'increaseButton': [{ type: ViewChild, args: ['increaseButton',] },],
    'labelTemplate': [{ type: ContentChild, args: [LabelTemplateDirective,] },],
    'direction': [{ type: HostBinding, args: ['attr.dir',] },],
    'horizontalClass': [{ type: HostBinding, args: ['class.k-slider-horizontal',] },],
    'verticalClass': [{ type: HostBinding, args: ['class.k-slider-vertical',] },],
    'sliderClass': [{ type: HostBinding, args: ['class.k-slider',] },],
    'transitionsClass': [{ type: HostBinding, args: ['class.k-slider-transitions',] },],
    'widgetClass': [{ type: HostBinding, args: ['class.k-widget',] },],
    'stateDefaultClass': [{ type: HostBinding, args: ['class.k-state-default',] },],
    'disabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
    'focusedClass': [{ type: HostBinding, args: ['class.k-state-focused',] },],
    'ariaDisabled': [{ type: HostBinding, args: ['attr.aria-disabled',] },],
    'ariaReadonly': [{ type: HostBinding, args: ['attr.aria-readonly',] },],
    'ariaMin': [{ type: HostBinding, args: ['attr.aria-valuemin',] },],
    'ariaMax': [{ type: HostBinding, args: ['attr.aria-valuemax',] },],
    'ariaValue': [{ type: HostBinding, args: ['attr.aria-valuenow',] },],
    'keydown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
};
